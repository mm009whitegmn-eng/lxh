<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>å–µç•Œè£è€€ 3Dï¼šæ³°å¦é™ä¸´</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Segoe UI', sans-serif; user-select: none; }
        
        /* UI å±‚ */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        
        /* ç™»å½•æ¡† */
        #login-panel {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.8); display: flex; flex-direction: column;
            justify-content: center; align-items: center; z-index: 10; pointer-events: auto;
            backdrop-filter: blur(5px);
        }
        
        .card-container { display: flex; gap: 20px; margin: 20px; }
        .role-card {
            width: 120px; height: 160px; background: rgba(255,255,255,0.1);
            border: 2px solid #555; border-radius: 10px; cursor: pointer;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            transition: 0.3s; color: white;
        }
        .role-card.selected { border-color: #00ff88; background: rgba(0,255,136, 0.1); transform: scale(1.1); box-shadow: 0 0 20px #00ff88; }
        .role-model-preview { font-size: 50px; margin-bottom: 10px; }
        
        input { padding: 15px; background: rgba(255,255,255,0.1); border: 1px solid #555; color: white; border-radius: 5px; text-align: center; font-size: 18px; margin-bottom: 20px; }
        button.start-btn { padding: 15px 40px; background: linear-gradient(45deg, #ff0055, #ffcc00); border: none; color: white; font-size: 20px; font-weight: bold; border-radius: 30px; cursor: pointer; }
        
        /* è™šæ‹Ÿæ‘‡æ† */
        #joystick-zone { position: absolute; bottom: 50px; left: 50px; width: 150px; height: 150px; pointer-events: auto; }
        
        /* æŠ€èƒ½æŒ‰é’® */
        .skill-btn {
            position: absolute; width: 80px; height: 80px; border-radius: 50%;
            background: rgba(255,255,255,0.2); border: 3px solid white; pointer-events: auto;
            right: 40px; bottom: 40px; display: flex; justify-content: center; align-items: center;
            font-weight: bold; color: white; font-size: 18px; box-shadow: 0 0 10px rgba(0,0,0,0.5);
        }
        .skill-btn:active { transform: scale(0.9); background: rgba(255,255,255,0.5); }
        
        /* çŠ¶æ€æ¡ */
        #hud { position: absolute; top: 20px; left: 20px; color: white; font-size: 14px; text-shadow: 1px 1px 2px black; }
        .bar { width: 150px; height: 10px; background: #333; margin-top: 5px; border-radius: 5px; overflow: hidden; }
        .fill { width: 100%; height: 100%; background: #00ff88; transition: width 0.2s; }
        
        #loading { position: absolute; top: 50%; left: 50%; transform: translate(-50%,-50%); color: white; display: none; }
    </style>
</head>
<body>

<div id="loading">æ­£åœ¨æ„å»º 3D ä¸–ç•Œ...</div>

<div id="login-panel">
    <h1 style="color:white; text-shadow: 0 0 20px #00a8ff; font-style: italic;">CAT LEGENDS 3D</h1>
    <input type="text" id="room-id" value="888" placeholder="è¾“å…¥æˆ¿é—´å·">
    
    <div class="card-container">
        <div class="role-card selected" onclick="selectRole('A')" id="card-a">
            <div class="role-model-preview">ğŸ¯</div>
            <div>å¹ºå¹º<br><span style="font-size:12px; opacity:0.7">é»„é‡‘æœºç”²</span></div>
        </div>
        <div class="role-card" onclick="selectRole('B')" id="card-b">
            <div class="role-model-preview">ğŸ¦</div>
            <div>çŸ³æ¦´<br><span style="font-size:12px; opacity:0.7">ç™½é“¶æˆ˜è½¦</span></div>
        </div>
    </div>
    
    <button class="start-btn" onclick="connectGame()">è¿›å…¥ 3D æˆ˜åœº</button>
</div>

<div id="ui-layer" style="display:none;">
    <div id="hud">
        <div id="p1-info">
            å¹ºå¹º (æˆ‘)
            <div class="bar"><div class="fill" id="hp-me"></div></div>
        </div>
        <br>
        <div id="p2-info" style="opacity: 0.5;">
            çŸ³æ¦´ (é˜Ÿå‹)
            <div class="bar"><div class="fill" id="hp-mate" style="background:#00a8ff; width:100%;"></div></div>
        </div>
    </div>

    <div id="joystick-zone"></div>
    
    <div class="skill-btn" ontouchstart="playerAttack(event)">æ”»å‡»</div>
</div>

<script>
// ==========================================
// 1. 3D æ¨¡å‹æ„å»ºå·¥åœº (The Model Factory)
// ==========================================
// æ—¢ç„¶ä¸èƒ½ä¸‹è½½æ¨¡å‹ï¼Œæˆ‘ä»¬å°±ç”¨ä»£ç â€œå †ç§¯æœ¨â€åšæ¨¡å‹

function createCatModel(role) {
    const group = new THREE.Group();
    
    // æè´¨
    const color = role === 'A' ? 0xffd700 : 0xecf0f1; // é‡‘è‰² or ç™½è‰²
    const matBody = new THREE.MeshStandardMaterial({ color: color, roughness: 0.3, metalness: 0.5 });
    const matDark = new THREE.MeshStandardMaterial({ color: 0x333333 });
    const matGlowing = new THREE.MeshBasicMaterial({ color: role === 'A' ? 0xff0000 : 0x00a8ff });

    // 1. èº«ä½“ (ä¸»ä½“)
    const bodyGeo = new THREE.BoxGeometry(1, 0.8, 1.2);
    const body = new THREE.Mesh(bodyGeo, matBody);
    body.position.y = 0.6;
    body.castShadow = true;
    group.add(body);

    // 2. å¤´éƒ¨
    const headGeo = new THREE.BoxGeometry(0.8, 0.7, 0.8);
    const head = new THREE.Mesh(headGeo, matBody);
    head.position.set(0, 1.2, 0.4);
    head.castShadow = true;
    group.add(head);

    // 3. è€³æœµ (ä¸¤ä¸ªé”¥ä½“)
    const earGeo = new THREE.ConeGeometry(0.15, 0.3, 4);
    const earL = new THREE.Mesh(earGeo, matBody);
    earL.position.set(-0.25, 1.6, 0.4);
    earL.rotation.y = -0.5;
    
    const earR = new THREE.Mesh(earGeo, matBody);
    earR.position.set(0.25, 1.6, 0.4);
    earR.rotation.y = 0.5;
    group.add(earL); group.add(earR);

    // 4. çœ¼ç› (å‘å…‰)
    const eyeGeo = new THREE.BoxGeometry(0.15, 0.05, 0.05);
    const eyeL = new THREE.Mesh(eyeGeo, matGlowing);
    eyeL.position.set(-0.2, 1.3, 0.81);
    const eyeR = new THREE.Mesh(eyeGeo, matGlowing);
    eyeR.position.set(0.2, 1.3, 0.81);
    group.add(eyeL); group.add(eyeR);

    // 5. å°¾å·´
    const tailGeo = new THREE.CylinderGeometry(0.05, 0.05, 0.8);
    const tail = new THREE.Mesh(tailGeo, matBody);
    tail.position.set(0, 0.8, -0.6);
    tail.rotation.x = -1;
    group.add(tail);

    // 6. ç®€å•çš„è„š/è½®å­
    const legGeo = new THREE.CylinderGeometry(0.15, 0.15, 0.4);
    const legFL = new THREE.Mesh(legGeo, matDark); legFL.position.set(-0.4, 0.2, 0.4);
    const legFR = new THREE.Mesh(legGeo, matDark); legFR.position.set(0.4, 0.2, 0.4);
    const legBL = new THREE.Mesh(legGeo, matDark); legBL.position.set(-0.4, 0.2, -0.4);
    const legBR = new THREE.Mesh(legGeo, matDark); legBR.position.set(0.4, 0.2, -0.4);
    group.add(legFL); group.add(legFR); group.add(legBL); group.add(legBR);

    // è¿™é‡Œçš„ group å°±æ˜¯ä¸€ä¸ªå®Œæ•´çš„ 3D çŒ«å’ªå¯¹è±¡
    return group;
}

function createTree() {
    const group = new THREE.Group();
    // æ ‘å¹²
    const trunk = new THREE.Mesh(
        new THREE.CylinderGeometry(0.2, 0.4, 1.5, 6),
        new THREE.MeshStandardMaterial({ color: 0x8B4513 })
    );
    trunk.position.y = 0.75;
    trunk.castShadow = true;
    
    // æ ‘å¶ (ä½å¤šè¾¹å½¢é£æ ¼)
    const leaves = new THREE.Mesh(
        new THREE.ConeGeometry(1.2, 2.5, 6),
        new THREE.MeshStandardMaterial({ color: 0x228B22 })
    );
    leaves.position.y = 2;
    leaves.castShadow = true;
    
    group.add(trunk);
    group.add(leaves);
    return group;
}

// ==========================================
// 2. 3D å¼•æ“è®¾ç½® (Three.js Setup)
// ==========================================
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x87CEEB); // å¤©ç©ºè“
scene.fog = new THREE.Fog(0x87CEEB, 10, 50); // é›¾æ°”æ•ˆæœ

const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
camera.position.set(0, 8, 8); // ä¿¯è§†è§†è§’
camera.lookAt(0, 0, 0);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.shadowMap.enabled = true; // å¼€å¯é˜´å½±
document.body.appendChild(renderer.domElement);

// ç¯å…‰
const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);
scene.add(hemiLight);

const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
dirLight.position.set(10, 20, 10);
dirLight.castShadow = true;
dirLight.shadow.camera.top = 20;
dirLight.shadow.camera.bottom = -20;
dirLight.shadow.camera.left = -20;
dirLight.shadow.camera.right = 20;
scene.add(dirLight);

// åœ°é¢
const groundGeo = new THREE.PlaneGeometry(100, 100);
const groundMat = new THREE.MeshStandardMaterial({ color: 0x3cb371 }); // è‰åœ°ç»¿
const ground = new THREE.Mesh(groundGeo, groundMat);
ground.rotation.x = -Math.PI / 2;
ground.receiveShadow = true;
scene.add(ground);

// è£…é¥°ï¼šç§æ ‘
for(let i=0; i<20; i++) {
    const tree = createTree();
    tree.position.set((Math.random()-0.5)*40, 0, (Math.random()-0.5)*40);
    // é¿å…ç§åœ¨å‡ºç”Ÿç‚¹
    if(Math.abs(tree.position.x) > 5 && Math.abs(tree.position.z) > 5) {
        scene.add(tree);
    }
}

// ==========================================
// 3. æ¸¸æˆé€»è¾‘
// ==========================================
let myRole = 'A';
const players = {}; // å­˜æ”¾æ‰€æœ‰ç©å®¶æ¨¡å‹
const projectiles = [];
let joystickData = { x: 0, y: 0 };

// åˆ›å»ºç©å®¶å‡½æ•°
function spawnPlayer(id, role, isMe) {
    if(players[id]) return; // å·²å­˜åœ¨

    const model = createCatModel(role);
    model.position.set(isMe ? -2 : 2, 0, 0); // ç¨å¾®é”™å¼€ä½ç½®
    scene.add(model);

    players[id] = {
        mesh: model,
        role: role,
        hp: 100,
        isMe: isMe
    };
    
    // å¦‚æœæ˜¯è‡ªå·±ï¼Œæ·»åŠ ä¸€ä¸ªå…‰åœˆ
    if(isMe) {
        const ring = new THREE.Mesh(
            new THREE.RingGeometry(0.8, 1, 32),
            new THREE.MeshBasicMaterial({ color: 0x00ff00, side: THREE.DoubleSide })
        );
        ring.rotation.x = -Math.PI/2;
        ring.position.y = 0.05;
        model.add(ring);
    }
}

// æ”»å‡»é€»è¾‘
window.playerAttack = function(e) {
    if(e) e.preventDefault();
    if(!players['me']) return;
    
    const me = players['me'].mesh;
    
    // ç®€å•çš„ç‰¹æ•ˆï¼šåˆ›å»ºä¸€ä¸ªçƒä½“ä½œä¸ºå­å¼¹
    const bullet = new THREE.Mesh(
        new THREE.SphereGeometry(0.2, 8, 8),
        new THREE.MeshBasicMaterial({ color: 0xffff00 })
    );
    bullet.position.copy(me.position);
    bullet.position.y = 0.8;
    
    // å­å¼¹æ–¹å‘ï¼šè§’è‰²å½“å‰æœå‘
    const direction = new THREE.Vector3(0, 0, 1);
    direction.applyQuaternion(me.quaternion);
    
    scene.add(bullet);
    projectiles.push({ mesh: bullet, dir: direction, life: 60 });
    
    // å‘é€ç½‘ç»œæ•°æ®
    if(Net.conn && Net.conn.open) {
        Net.conn.send({ type: 'atk', x: me.position.x, z: me.position.z, ry: me.rotation.y });
    }
}

function updateGame() {
    // 1. æœ¬åœ°ç©å®¶ç§»åŠ¨
    if(players['me']) {
        const me = players['me'].mesh;
        if(joystickData.x !== 0 || joystickData.y !== 0) {
            // è®¡ç®—ç§»åŠ¨
            const speed = 0.15;
            me.position.x += joystickData.x * speed;
            me.position.z += joystickData.y * speed;
            
            // è®¡ç®—æ—‹è½¬ï¼šè§’è‰²é¢å‘ç§»åŠ¨æ–¹å‘
            const angle = Math.atan2(joystickData.x, joystickData.y);
            me.rotation.y = angle;
            
            // æ‘„åƒæœºå¹³æ»‘è·Ÿéš
            camera.position.x += (me.position.x - camera.position.x) * 0.1;
            camera.position.z += (me.position.z + 8 - camera.position.z) * 0.1;
            
            // ç½‘ç»œåŒæ­¥
            if(Net.conn && Net.conn.open) {
                Net.conn.send({ type: 'move', x: me.position.x, z: me.position.z, ry: me.rotation.y });
            }
        }
    }
    
    // 2. å­å¼¹æ›´æ–°
    for(let i = projectiles.length - 1; i >= 0; i--) {
        const p = projectiles[i];
        p.mesh.position.addScaledVector(p.dir, 0.4);
        p.life--;
        if(p.life <= 0) {
            scene.remove(p.mesh);
            projectiles.splice(i, 1);
        }
    }
    
    renderer.render(scene, camera);
    requestAnimationFrame(updateGame);
}

// ==========================================
// 4. æ‘‡æ†äº¤äº’ (Touch)
// ==========================================
const joyZone = document.getElementById('joystick-zone');
let joyTouchId = null;
let joyStart = {x:0, y:0};

joyZone.addEventListener('touchstart', (e) => {
    e.preventDefault();
    const touch = e.changedTouches[0];
    joyTouchId = touch.identifier;
    joyStart = { x: touch.clientX, y: touch.clientY };
    
    // è§†è§‰åé¦ˆï¼šè¿™é‡Œå¯ä»¥åˆ›å»ºä¸€ä¸ªåœ†çƒè·Ÿéšæ‰‹æŒ‡ï¼ˆä¸ºäº†ä»£ç ç®€æ´çœç•¥ï¼‰
});

joyZone.addEventListener('touchmove', (e) => {
    e.preventDefault();
    for(let i=0; i<e.changedTouches.length; i++) {
        if(e.changedTouches[i].identifier === joyTouchId) {
            const touch = e.changedTouches[i];
            const dx = touch.clientX - joyStart.x;
            const dy = touch.clientY - joyStart.y;
            
            // å½’ä¸€åŒ–å‘é‡
            const dist = Math.sqrt(dx*dx + dy*dy);
            const maxDist = 50; 
            const scale = Math.min(dist, maxDist) / maxDist;
            
            if(dist > 0) {
                joystickData.x = (dx/dist) * scale;
                joystickData.y = (dy/dist) * scale;
            }
        }
    }
});

joyZone.addEventListener('touchend', () => {
    joystickData = { x: 0, y: 0 };
    joyTouchId = null;
});

// ==========================================
// 5. ç½‘ç»œè”æœº (PeerJS) - é€‚é… 3D æ•°æ®
// ==========================================
const Net = {
    conn: null,
    init: function(roomId, onConnect) {
        document.getElementById('loading').style.display = 'block';
        const myPeerId = "CAT3D_" + Math.floor(Math.random()*10000);
        const peer = new Peer(myPeerId);
        const hostId = "CAT3D_ROOM_" + roomId;
        
        peer.on('open', (id) => {
            // å°è¯•è¿æ¥ Host
            const conn = peer.connect(hostId);
            
            conn.on('open', () => {
                // è¿æ¥æˆåŠŸï¼Œæˆ‘æ˜¯ Guest
                this.conn = conn;
                this.setup(onConnect, false);
            });
            
            // è¿ä¸ä¸Š Hostï¼Œæˆ‘è‡ªå·±åš Host
            setTimeout(() => {
                if(!this.conn || !this.conn.open) {
                    console.log("Creating Host...");
                    peer.destroy();
                    const hostPeer = new Peer(hostId);
                    hostPeer.on('connection', (c) => {
                        this.conn = c;
                        this.setup(onConnect, true); // true = Host é€»è¾‘
                    });
                    // æˆ‘è‡ªå·±å…ˆå¼€å§‹
                    spawnPlayer('me', myRole, true);
                    onConnect();
                }
            }, 2000);
        });
    },
    
    setup: function(onConnect, isHost) {
        document.getElementById('loading').style.display = 'none';
        
        // å‘Šè¯‰å¯¹æ–¹æˆ‘çš„è§’è‰²
        this.conn.send({ type: 'init', role: myRole });
        
        // å¦‚æœæˆ‘æ˜¯ Guestï¼Œè¿æ¥æˆåŠŸåæˆ‘ä¹Ÿè¦ç”Ÿæˆè‡ªå·±
        if(!isHost) {
            spawnPlayer('me', myRole, true);
            onConnect();
        }
        
        this.conn.on('data', (data) => {
            if(data.type === 'init') {
                // å¯¹æ–¹åŠ å…¥äº†ï¼Œç”Ÿæˆå¯¹æ–¹çš„æ¨¡å‹
                spawnPlayer('mate', data.role, false);
                // æˆ‘ä¹Ÿå†å‘Šè¯‰å¯¹æ–¹ä¸€æ¬¡æˆ‘çš„è§’è‰²ï¼ˆåŒé‡ç¡®è®¤ï¼‰
                this.conn.send({ type: 'init_ack', role: myRole });
            } else if (data.type === 'init_ack') {
                spawnPlayer('mate', data.role, false);
            } else if (data.type === 'move') {
                // åŒæ­¥å¯¹æ–¹ä½ç½®
                if(players['mate']) {
                    const mate = players['mate'].mesh;
                    mate.position.set(data.x, 0, data.z);
                    mate.rotation.y = data.ry;
                }
            } else if (data.type === 'atk') {
                // å¯¹æ–¹æ”»å‡»ï¼Œæˆ‘ä¹Ÿè¦ç”Ÿæˆä¸€ä¸ªå­å¼¹è§†è§‰
                const bullet = new THREE.Mesh(
                    new THREE.SphereGeometry(0.2, 8, 8),
                    new THREE.MeshBasicMaterial({ color: 0xff0000 })
                );
                bullet.position.set(data.x, 0.8, data.z);
                const dir = new THREE.Vector3(0,0,1).applyEuler(new THREE.Euler(0, data.ry, 0));
                scene.add(bullet);
                projectiles.push({ mesh: bullet, dir: dir, life: 60 });
            }
        });
    }
};

// UI é€»è¾‘
function selectRole(r) {
    myRole = r;
    document.querySelectorAll('.role-card').forEach(e => e.classList.remove('selected'));
    document.getElementById('card-' + r.toLowerCase()).classList.add('selected');
}

function connectGame() {
    const room = document.getElementById('room-id').value;
    if(!room) return alert("è¯·è¾“å…¥æˆ¿é—´å·");
    document.getElementById('login-panel').style.display = 'none';
    
    Net.init(room, () => {
        document.getElementById('ui-layer').style.display = 'block';
        updateGame(); // å¼€å§‹æ¸²æŸ“å¾ªç¯
    });
}

// çª—å£å¤§å°é€‚é…
window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});

</script>
</body>
</html>
