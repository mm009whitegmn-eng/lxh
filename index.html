<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>å–µç•Œè£è€€ï¼šåŒç”Ÿå®ˆæŠ¤</title>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <style>
        /* --- æ²‰æµ¸å¼æ¸¸æˆæ ·å¼ --- */
        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Segoe UI', sans-serif; touch-action: none; user-select: none; }
        
        /* å…¨å±ç”»å¸ƒ */
        canvas { display: block; width: 100%; height: 100%; }

        /* UI å±‚ */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; overflow: hidden; }

        /* ç™»å½•ç•Œé¢ */
        #login-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(135deg, #1a2a6c, #b21f1f, #fdbb2d);
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            z-index: 999; pointer-events: auto;
        }
        .login-box {
            background: rgba(0,0,0,0.8); padding: 30px; border-radius: 20px;
            border: 2px solid rgba(255,255,255,0.2); text-align: center; color: white;
            backdrop-filter: blur(10px); width: 90%; max-width: 400px;
        }
        .role-card {
            display: inline-block; width: 100px; height: 100px; margin: 10px;
            border-radius: 15px; border: 3px solid transparent; cursor: pointer;
            transition: transform 0.2s; position: relative;
        }
        .role-card.selected { border-color: #00ff88; transform: scale(1.1); box-shadow: 0 0 20px #00ff88; }
        .role-card img { width: 100%; height: 100%; border-radius: 12px; object-fit: cover; }
        
        input.room-input {
            background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.3);
            color: white; padding: 15px; font-size: 20px; text-align: center;
            border-radius: 10px; width: 100%; margin-bottom: 20px; outline: none;
        }
        
        button.start-btn {
            background: linear-gradient(45deg, #00c6ff, #0072ff); border: none;
            color: white; padding: 15px 40px; font-size: 20px; border-radius: 30px;
            font-weight: bold; cursor: pointer; box-shadow: 0 5px 15px rgba(0,114,255,0.4);
            width: 100%; margin-top: 10px;
        }

        /* æ¸¸æˆå†… HUD */
        .hud-top {
            position: absolute; top: 0; left: 0; width: 100%; padding: 10px;
            display: flex; justify-content: space-between; font-weight: bold;
            color: white; text-shadow: 0 2px 4px black; font-size: 14px;
        }
        .bar-container { width: 100px; height: 10px; background: #333; border-radius: 5px; overflow: hidden; margin-top: 5px; }
        .hp-bar { height: 100%; background: #ff4757; width: 100%; transition: width 0.2s; }
        .exp-bar { height: 100%; background: #eccc68; width: 0%; transition: width 0.2s; }

        /* è™šæ‹Ÿæ‘‡æ†ä¸æŒ‰é’® */
        #controls-area { position: absolute; bottom: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        
        /* æŠ€èƒ½æŒ‰é’®ç»„ */
        .skill-btn {
            position: absolute; width: 70px; height: 70px; border-radius: 50%;
            background: rgba(0,0,0,0.5); border: 2px solid white; pointer-events: auto;
            display: flex; justify-content: center; align-items: center; color: white;
            font-weight: bold; font-size: 14px; touch-action: manipulation;
        }
        .skill-btn:active { transform: scale(0.9); background: rgba(255,255,255,0.3); }
        .cooldown-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            border-radius: 50%; background: rgba(0,0,0,0.7);
            display: flex; justify-content: center; align-items: center; font-size: 20px;
        }

        #atk-btn { bottom: 40px; right: 40px; width: 80px; height: 80px; background: rgba(255, 50, 50, 0.4); border-color: #ff6b81; }
        #ult-btn { bottom: 140px; right: 50px; background: rgba(50, 150, 255, 0.4); border-color: #70a1ff; }

        /* æç¤ºä¿¡æ¯ */
        #msg-toast {
            position: absolute; top: 20%; left: 50%; transform: translateX(-50%);
            background: rgba(0,0,0,0.8); color: #00ff88; padding: 10px 20px;
            border-radius: 20px; opacity: 0; transition: opacity 0.5s; text-align: center;
        }
    </style>
</head>
<body>

<canvas id="gameCanvas"></canvas>

<div id="login-screen">
    <div class="login-box">
        <h2>âš”ï¸ å–µç•Œè£è€€</h2>
        <p style="color:#aaa; font-size:12px;">æ— éœ€æ³¨å†Œï¼Œè¾“å…¥ç›¸åŒæˆ¿é—´å·å³å¯è‡ªåŠ¨åŒ¹é…</p>
        
        <input type="number" id="room-input" class="room-input" value="888" placeholder="æˆ¿é—´å· (å¦‚: 888)">
        
        <div style="margin: 20px 0;">
            <p>é€‰æ‹©è‹±é›„</p>
            <div class="role-card selected" id="role-a" onclick="selectRole('A')">
                <div style="background:#ffd700; height:100%; border-radius:12px; display:flex; align-items:center; justify-content:center; font-size:40px;">ğŸ±</div>
                <div style="position:absolute; bottom:5px; width:100%; text-align:center; font-size:12px; color:black; font-weight:bold;">å¹ºå¹º(æ³•å¸ˆ)</div>
            </div>
            <div class="role-card" id="role-b" onclick="selectRole('B')">
                <div style="background:#f1f2f6; height:100%; border-radius:12px; display:flex; align-items:center; justify-content:center; font-size:40px;">ğŸ˜¼</div>
                <div style="position:absolute; bottom:5px; width:100%; text-align:center; font-size:12px; color:black; font-weight:bold;">çŸ³æ¦´(æˆ˜å£«)</div>
            </div>
        </div>

        <button class="start-btn" id="connect-btn" onclick="tryConnect()">å¼€å§‹åŒ¹é…</button>
        <p id="status-text" style="margin-top:10px; color:#ffeb3b; min-height:20px;"></p>
    </div>
</div>

<div id="ui-layer" style="display:none;">
    <div class="hud-top">
        <div style="margin-left:10px;">
            <div id="p1-name">æˆ‘</div>
            <div class="bar-container"><div class="hp-bar" id="hud-hp-me"></div></div>
            <div style="font-size:10px; color:#eccc68;">Lv.<span id="hud-lv-me">1</span></div>
        </div>
        <div style="text-align:center;">
            <div>ğŸ›¡ï¸ åŸºåœ°æ°´æ™¶</div>
            <div class="bar-container" style="width:150px;"><div class="hp-bar" id="hud-hp-base" style="background:#00a8ff;"></div></div>
            <div style="font-size:12px; margin-top:5px;">æ³¢æ¬¡: <span id="wave-num">1</span></div>
        </div>
        <div style="margin-right:10px; text-align:right;">
            <div id="p2-name">é˜Ÿå‹</div>
            <div class="bar-container"><div class="hp-bar" id="hud-hp-mate"></div></div>
            <div style="font-size:10px; color:#aaa;">(ç¦»çº¿)</div>
        </div>
    </div>

    <div id="msg-toast">æ¬¢è¿æ¥åˆ°å–µç•Œå³¡è°·ï¼</div>

    <div id="controls-area">
        <div id="atk-btn" class="skill-btn">æ™®æ”»</div>
        
        <div id="ult-btn" class="skill-btn">
            å¤§æ‹›
            <div class="cooldown-overlay" id="cd-overlay" style="display:none;">0</div>
        </div>
    </div>
</div>

<script>
// ==========================================
// 1. æ ¸å¿ƒç½‘ç»œå¼•æ“ (è‡ªåŠ¨åŒ¹é…é€»è¾‘)
// ==========================================
const Net = {
    peer: null,
    conn: null,
    isHost: false,
    myId: '',
    roomId: '',
    
    init: function(roomId, onConnected) {
        this.roomId = "MEOW_MOBA_ROOM_" + roomId;
        // å°è¯•ä½œä¸º HOST åˆå§‹åŒ– (ID = æˆ¿é—´å·_HOST)
        const hostId = this.roomId + "_HOST";
        
        document.getElementById('status-text').innerText = "æ­£åœ¨å¯»æ‰¾é˜Ÿå‹...";
        
        // é€»è¾‘ï¼šå…ˆå°è¯•è¿æ¥ Hostï¼Œè¿ä¸ä¸Šåˆ™è‡ªå·±æˆä¸º Host
        const tempPeer = new Peer();
        
        tempPeer.on('open', (id) => {
            // å°è¯•è¿æ¥æŒ‡å®šçš„ HOST ID
            const conn = tempPeer.connect(hostId);
            
            conn.on('open', () => {
                // è¿æ¥æˆåŠŸ -> æˆ‘æ˜¯å®¢æˆ·ç«¯ (Client)
                console.log("æ‰¾åˆ°æˆ¿ä¸»ï¼Œæˆ‘æ˜¯å®¢æˆ·ç«¯");
                this.peer = tempPeer;
                this.conn = conn;
                this.isHost = false;
                this.setupConnection(onConnected);
            });
            
            // å¦‚æœè¿æ¥å¤±è´¥ï¼ˆå‡ ç§’åï¼‰ï¼Œè¯´æ˜æ²¡æœ‰Hostï¼Œæˆ‘è‡ªå·±å½“Host
            setTimeout(() => {
                if (!this.conn || !this.conn.open) {
                    console.log("æœªæ‰¾åˆ°æˆ¿ä¸»ï¼Œæˆ‘åˆ›å»ºæˆ¿é—´");
                    tempPeer.destroy(); // é”€æ¯ä¸´æ—¶ID
                    this.createHost(hostId, onConnected);
                }
            }, 2000);
        });
        
        tempPeer.on('error', (err) => {
            // é”™è¯¯é€šå¸¸æ„å‘³ç€ Host ä¸å­˜åœ¨æˆ–ç½‘ç»œé—®é¢˜ï¼Œå°è¯•æˆä¸º Host
            console.log("è¿æ¥é”™è¯¯ï¼Œå°è¯•æˆä¸ºHost");
            this.createHost(hostId, onConnected);
        });
    },

    createHost: function(hostId, onConnected) {
        this.peer = new Peer(hostId); // å¼ºåˆ¶å ç”¨ HOST ID
        this.isHost = true;
        
        this.peer.on('open', () => {
            document.getElementById('status-text').innerText = "å·²å»ºç«‹æˆ¿é—´ï¼Œç­‰å¾…é˜Ÿå‹...";
        });

        this.peer.on('connection', (c) => {
            console.log("é˜Ÿå‹å·²è¿æ¥ï¼");
            this.conn = c;
            this.setupConnection(onConnected);
        });
        
        this.peer.on('error', (err) => {
            if(err.type === 'unavailable-id') {
                // æç½•è§æƒ…å†µï¼šä¸¤ä¸ªäººåŒæ—¶æŠ¢ Host
                alert("æˆ¿é—´æ‹¥æŒ¤ï¼Œè¯·æ¢ä¸ªå·ç ï¼");
                location.reload();
            }
        });
    },

    setupConnection: function(callback) {
        document.getElementById('status-text').innerText = "è¿æ¥æˆåŠŸï¼è¿›å…¥æ¸¸æˆ...";
        setTimeout(() => {
            document.getElementById('login-screen').style.display = 'none';
            document.getElementById('ui-layer').style.display = 'block';
            callback();
        }, 1000);

        this.conn.on('data', (data) => Game.onNetworkData(data));
        this.conn.on('close', () => Game.showToast("é˜Ÿå‹æ–­å¼€è¿æ¥"));
    },

    send: function(data) {
        if (this.conn && this.conn.open) {
            this.conn.send(data);
        }
    }
};

// ==========================================
// 2. æ¸¸æˆæ•°æ®ä¸é€»è¾‘
// ==========================================
const CONFIG = {
    A: { name: 'å¹ºå¹º', color: '#ffd700', hp: 800, speed: 5, type: 'mage', skillCd: 300 },
    B: { name: 'çŸ³æ¦´', color: '#f1f2f6', hp: 1200, speed: 4.5, type: 'tank', skillCd: 500 }
};

let myRole = 'A'; 

// æ‘‡æ†é€»è¾‘
const Joystick = {
    active: false,
    origin: {x:0, y:0},
    current: {x:0, y:0},
    vector: {x:0, y:0}, // å½’ä¸€åŒ–å‘é‡
    id: null,
    
    init: function() {
        const zone = document.getElementById('ui-layer');
        zone.addEventListener('touchstart', e => {
            for(let i=0; i<e.changedTouches.length; i++) {
                const t = e.changedTouches[i];
                if(t.clientX < window.innerWidth / 2) { // å·¦åŠå±
                    this.start(t.identifier, t.clientX, t.clientY);
                }
            }
        });
        zone.addEventListener('touchmove', e => {
            for(let i=0; i<e.changedTouches.length; i++) {
                if(e.changedTouches[i].identifier === this.id) {
                    this.move(e.changedTouches[i].clientX, e.changedTouches[i].clientY);
                }
            }
        });
        zone.addEventListener('touchend', e => {
            for(let i=0; i<e.changedTouches.length; i++) {
                if(e.changedTouches[i].identifier === this.id) this.end();
            }
        });
    },
    start: function(id, x, y) { this.active=true; this.id=id; this.origin={x,y}; this.current={x,y}; this.vector={x:0,y:0}; },
    move: function(x, y) {
        this.current = {x, y};
        const dx = x - this.origin.x;
        const dy = y - this.origin.y;
        const dist = Math.sqrt(dx*dx + dy*dy);
        const maxDist = 50;
        
        if(dist > 0) {
            const scale = Math.min(dist, maxDist);
            this.vector = { x: (dx/dist), y: (dy/dist) };
            // é™åˆ¶æ‘‡æ†è§†è§‰èŒƒå›´
            this.current.x = this.origin.x + this.vector.x * scale;
            this.current.y = this.origin.y + this.vector.y * scale;
        }
    },
    end: function() { this.active=false; this.id=null; this.vector={x:0,y:0}; }
};

// æŠ€èƒ½æŒ‰é’®ç»‘å®š
document.getElementById('atk-btn').addEventListener('touchstart', (e) => { e.preventDefault(); Game.myAction('atk'); });
document.getElementById('ult-btn').addEventListener('touchstart', (e) => { e.preventDefault(); Game.myAction('ult'); });

// ==========================================
// 3. æ¸¸æˆä¸»å¼•æ“
// ==========================================
const Game = {
    canvas: document.getElementById('gameCanvas'),
    ctx: document.getElementById('gameCanvas').getContext('2d'),
    
    width: 0, height: 0,
    camera: {x:0, y:0},
    
    // å®ä½“
    me: { x:0, y:0, hp:100, maxHp:100, lv:1, exp:0, cd:0, role:'A', action:null, shield:0 },
    mate: { x:0, y:0, hp:100, maxHp:100, active:false, role:'B', action:null, shield:0 },
    base: { x:0, y:0, hp:5000, maxHp:5000 },
    
    enemies: [],
    particles: [],
    projectiles: [],
    texts: [],
    
    frameCount: 0,
    wave: 1,
    
    init: function() {
        this.resize();
        window.addEventListener('resize', () => this.resize());
        Joystick.init();
        
        // åˆå§‹åŒ–ä½ç½®
        this.base.x = 0; this.base.y = 0; // åŸºåœ°åœ¨åœ°å›¾ä¸­å¿ƒ (0,0)
        this.me.x = 100; this.me.y = 100;
        
        const roleData = CONFIG[myRole];
        this.me.hp = this.me.maxHp = roleData.hp;
        this.me.role = myRole;
        
        // å¯åŠ¨å¾ªç¯
        requestAnimationFrame(() => this.loop());
        
        // åªæœ‰æˆ¿ä¸»è´Ÿè´£ç”Ÿæˆæ€ªç‰©
        if(Net.isHost) setInterval(() => this.spawnWave(), 5000);
    },
    
    resize: function() {
        this.width = this.canvas.width = window.innerWidth;
        this.height = this.canvas.height = window.innerHeight;
    },
    
    myAction: function(type) {
        if(this.me.hp <= 0) return;
        
        if(type === 'ult') {
            if(this.me.cd > 0) {
                this.showToast("æŠ€èƒ½å†·å´ä¸­!");
                return;
            }
            this.me.cd = CONFIG[this.me.role].skillCd;
            this.performSkill(this.me, true); // true = isUlt
        } else {
            // æ™®æ”»
            this.performSkill(this.me, false);
        }
        
        // å‘é€ç»™é˜Ÿå‹
        Net.send({ type: 'action', act: type, x: this.me.x, y: this.me.y });
    },
    
    performSkill: function(entity, isUlt) {
        const role = entity.role;
        const isMe = entity === this.me;
        
        if(role === 'A') { // å¹ºå¹º (æ³•å¸ˆ)
            if(isUlt) {
                // å¤§æ‹›ï¼šå…¨å±æ²»ç–— + å¤§èŒƒå›´ä¼¤å®³
                this.addParticle(entity.x, entity.y, '#ffd700', 100, 'shockwave');
                this.shakeScreen(10);
                if(isMe) this.damageArea(entity.x, entity.y, 300, 500); // ä¼¤å®³
                // æ²»ç–—
                entity.hp = Math.min(entity.hp + 200, entity.maxHp);
                if(this.mate.active) this.mate.hp = Math.min(this.mate.hp + 200, this.mate.maxHp);
            } else {
                // æ™®æ”»ï¼šç«çƒ
                // å¯»æ‰¾æœ€è¿‘æ•Œäºº
                let target = this.findNearestEnemy(entity);
                let angle = 0;
                if(target) angle = Math.atan2(target.y - entity.y, target.x - entity.x);
                else angle = isMe ? Math.atan2(Joystick.vector.y, Joystick.vector.x) : 0;
                
                this.projectiles.push({
                    x: entity.x, y: entity.y,
                    vx: Math.cos(angle)*10, vy: Math.sin(angle)*10,
                    life: 60, owner: entity, damage: 50
                });
            }
        } else { // çŸ³æ¦´ (æˆ˜å£«)
            if(isUlt) {
                // å¤§æ‹›ï¼šæŠ¤ç›¾ + å˜²è®½
                entity.shield = 300; // æŠ¤ç›¾æŒç»­æ—¶é—´/å€¼
                this.addParticle(entity.x, entity.y, '#00a8ff', 80, 'ring');
                if(isMe) this.showToast("é›·éœ†æŠ¤ç›¾å¼€å¯ï¼");
            } else {
                // æ™®æ”»ï¼šè¿‘æˆ˜æŒ¥ç 
                this.addParticle(entity.x, entity.y, '#fff', 20, 'slash');
                if(isMe) this.damageArea(entity.x, entity.y, 80, 80);
            }
        }
    },
    
    damageArea: function(x, y, range, dmg) {
        this.enemies.forEach(e => {
            if(Math.hypot(e.x - x, e.y - y) < range) {
                e.hp -= dmg;
                this.addFloatText(e.x, e.y, "-" + dmg, "red");
                this.addParticle(e.x, e.y, "#ff0000", 10, "spark");
            }
        });
    },
    
    findNearestEnemy: function(origin) {
        let nearest = null;
        let minDst = 9999;
        this.enemies.forEach(e => {
            const d = Math.hypot(e.x - origin.x, e.y - origin.y);
            if(d < minDst) { minDst = d; nearest = e; }
        });
        return nearest;
    },
    
    spawnWave: function() {
        if(!this.base.hp > 0) return;
        this.wave++;
        const count = 3 + Math.floor(this.wave / 2);
        for(let i=0; i<count; i++) {
            const angle = Math.random() * Math.PI * 2;
            const dist = 800 + Math.random() * 200;
            this.enemies.push({
                x: Math.cos(angle)*dist, y: Math.sin(angle)*dist,
                hp: 100 + this.wave*20, maxHp: 100 + this.wave*20,
                speed: 1 + Math.random(),
                target: 'base'
            });
        }
        
        // åªè¦ç”Ÿæˆäº†ï¼Œå°±åŒæ­¥ç»™å®¢æˆ·ç«¯
        if(Net.isHost) {
            Net.send({ type: 'syncEnemies', data: this.enemies });
            Net.send({ type: 'waveInfo', wave: this.wave });
        }
    },

    onNetworkData: function(data) {
        if(data.type === 'move') {
            this.mate.x = data.x;
            this.mate.y = data.y;
            this.mate.hp = data.hp;
            this.mate.active = true;
            this.mate.role = data.role;
        } else if (data.type === 'action') {
            // é˜Ÿå‹æ”¾æŠ€èƒ½
            this.mate.x = data.x; // ä¿®æ­£ä½ç½®
            this.mate.y = data.y;
            this.performSkill(this.mate, data.act === 'ult');
        } else if (data.type === 'syncEnemies' && !Net.isHost) {
            // å®¢æˆ·ç«¯ç›´æ¥æ¥æ”¶æ€ªç‰©åˆ—è¡¨
            this.enemies = data.data;
        } else if (data.type === 'waveInfo') {
            this.wave = data.wave;
            document.getElementById('wave-num').innerText = this.wave;
        } else if (data.type === 'baseDmg') {
            this.base.hp = data.hp;
        }
    },

    update: function() {
        this.frameCount++;
        
        // 1. ç©å®¶ç§»åŠ¨
        if(Joystick.active && this.me.hp > 0) {
            const speed = CONFIG[this.me.role].speed;
            this.me.x += Joystick.vector.x * speed;
            this.me.y += Joystick.vector.y * speed;
        }
        
        // å†·å´
        if(this.me.cd > 0) {
            this.me.cd--;
            const overlay = document.getElementById('cd-overlay');
            overlay.style.display = 'flex';
            overlay.innerText = Math.ceil(this.me.cd / 60);
        } else {
            document.getElementById('cd-overlay').style.display = 'none';
        }
        
        if(this.me.shield > 0) this.me.shield--;

        // 2. æ‘„åƒæœºè·Ÿéš (å¹³æ»‘)
        this.camera.x += (this.me.x - this.width/2 - this.camera.x) * 0.1;
        this.camera.y += (this.me.y - this.height/2 - this.camera.y) * 0.1;

        // 3. æ•Œäººé€»è¾‘ (Host è®¡ç®—)
        if(Net.isHost) {
            let baseHit = false;
            this.enemies.forEach(e => {
                // ä»‡æ¨åˆ¤æ–­
                const distMe = Math.hypot(e.x - this.me.x, e.y - this.me.y);
                const distMate = this.mate.active ? Math.hypot(e.x - this.mate.x, e.y - this.mate.y) : 9999;
                const distBase = Math.hypot(e.x - this.base.x, e.y - this.base.y);
                
                let targetPos = this.base;
                if(distMe < 200) targetPos = this.me;
                else if(distMate < 200) targetPos = this.mate;
                
                // ç§»åŠ¨
                const angle = Math.atan2(targetPos.y - e.y, targetPos.x - e.x);
                e.x += Math.cos(angle) * e.speed;
                e.y += Math.sin(angle) * e.speed;
                
                // æ”»å‡»åˆ¤å®š
                if(distMe < 30 && this.frameCount % 30 === 0) {
                    if(this.me.shield <= 0) this.me.hp -= 10;
                }
                if(distBase < 50 && this.frameCount % 10 === 0) {
                    this.base.hp -= 5;
                    baseHit = true;
                }
            });
            
            // æ¸…ç†æ­»æ€ª
            const prevLen = this.enemies.length;
            this.enemies = this.enemies.filter(e => e.hp > 0);
            if(this.enemies.length < prevLen) {
                // åªæœ‰HoståŠ ç»éªŒï¼Œè¿™é‡Œç®€åŒ–ä¸ºåŒæ­¥
                Net.send({ type: 'syncEnemies', data: this.enemies });
            }
            if(baseHit) Net.send({ type: 'baseDmg', hp: this.base.hp });
        }
        
        // å®¢æˆ·ç«¯ä¹Ÿéœ€è¦åœ¨æœ¬åœ°æ¨¡æ‹ŸæŠ•å°„ç‰©ï¼Œä½†ä¸å†³å®šç”Ÿæ­»
        this.projectiles.forEach(p => {
            p.x += p.vx; p.y += p.vy; p.life--;
            // ç®€å•çš„ç¢°æ’è§†è§‰
            if(Net.isHost) {
                this.enemies.forEach(e => {
                    if(Math.hypot(e.x - p.x, e.y - p.y) < 20) {
                        e.hp -= p.damage;
                        p.life = 0;
                        Net.send({ type: 'syncEnemies', data: this.enemies }); // ç«‹å³åŒæ­¥å‡»ä¸­çŠ¶æ€
                    }
                });
            }
        });
        this.projectiles = this.projectiles.filter(p => p.life > 0);
        
        // ç²’å­æ›´æ–°
        this.particles.forEach(p => {
            p.x += p.vx; p.y += p.vy; p.life--;
            p.size *= 0.95;
        });
        this.particles = this.particles.filter(p => p.life > 0);
        
        // æ–‡å­—æ›´æ–°
        this.texts.forEach(t => { t.y--; t.life--; });
        this.texts = this.texts.filter(t => t.life > 0);

        // ç½‘ç»œåŒæ­¥è‡ªå·±çš„çŠ¶æ€
        if(this.frameCount % 5 === 0) { // é™ä½é¢‘ç‡
            Net.send({ type: 'move', x: this.me.x, y: this.me.y, hp: this.me.hp, role: this.me.role });
        }
        
        // UI æ›´æ–°
        this.updateHUD();
        
        if(this.base.hp <= 0) {
            alert("åŸºåœ°è¢«æ‘§æ¯ï¼æ¸¸æˆç»“æŸï¼");
            location.reload();
        }
    },
    
    draw: function() {
        const cx = this.camera.x;
        const cy = this.camera.y;
        
        // 1. åœ°é¢æ¸²æŸ“ (è‰åœ° + ç½‘æ ¼)
        this.ctx.fillStyle = '#1e272e';
        this.ctx.fillRect(0, 0, this.width, this.height);
        
        this.ctx.strokeStyle = 'rgba(255,255,255,0.05)';
        this.ctx.beginPath();
        const gridSize = 100;
        const offsetX = -cx % gridSize;
        const offsetY = -cy % gridSize;
        for(let x=offsetX; x<this.width; x+=gridSize) { this.ctx.moveTo(x,0); this.ctx.lineTo(x,this.height); }
        for(let y=offsetY; y<this.height; y+=gridSize) { this.ctx.moveTo(0,y); this.ctx.lineTo(this.width,y); }
        this.ctx.stroke();
        
        // 2. ç»˜åˆ¶åŸºåœ°æ°´æ™¶
        this.drawEntity(this.base.x, this.base.y, 40, '#00d2d3', 'ğŸ’ ');
        // æ°´æ™¶è¡€æ¡
        this.ctx.fillStyle = 'red';
        this.ctx.fillRect(this.base.x-cx-30, this.base.y-cy-60, 60, 5);
        this.ctx.fillStyle = '#00d2d3';
        this.ctx.fillRect(this.base.x-cx-30, this.base.y-cy-60, 60 * (this.base.hp/this.base.maxHp), 5);

        // 3. ç»˜åˆ¶æ•Œäºº (æ€ªå…½)
        this.enemies.forEach(e => {
            this.drawEntity(e.x, e.y, 15, '#ff4757', 'ğŸ‘¾');
            // è¡€æ¡
            this.ctx.fillStyle = 'red';
            this.ctx.fillRect(e.x-cx-15, e.y-cy-25, 30, 4);
            this.ctx.fillStyle = '#2ed573';
            this.ctx.fillRect(e.x-cx-15, e.y-cy-25, 30 * (e.hp/e.maxHp), 4);
        });
        
        // 4. ç»˜åˆ¶é˜Ÿå‹
        if(this.mate.active) {
            this.drawPlayer(this.mate);
        }
        
        // 5. ç»˜åˆ¶è‡ªå·±
        this.drawPlayer(this.me);
        
        // 6. æŠ•å°„ç‰©
        this.ctx.fillStyle = '#ff9f43';
        this.projectiles.forEach(p => {
            this.ctx.beginPath();
            this.ctx.arc(p.x-cx, p.y-cy, 5, 0, Math.PI*2);
            this.ctx.fill();
        });

        // 7. ç²’å­ç‰¹æ•ˆ (é«˜å…‰)
        this.ctx.globalCompositeOperation = 'lighter';
        this.particles.forEach(p => {
            this.ctx.fillStyle = p.color;
            if(p.type === 'shockwave') {
                this.ctx.beginPath();
                this.ctx.strokeStyle = p.color;
                this.ctx.lineWidth = 5;
                this.ctx.arc(p.x-cx, p.y-cy, (100-p.life)*2, 0, Math.PI*2);
                this.ctx.stroke();
            } else if (p.type === 'ring') {
                 this.ctx.beginPath();
                this.ctx.strokeStyle = p.color;
                this.ctx.lineWidth = 2;
                this.ctx.arc(p.x-cx, p.y-cy, 50, 0, Math.PI*2);
                this.ctx.stroke();
            } else {
                this.ctx.beginPath();
                this.ctx.arc(p.x-cx, p.y-cy, p.size, 0, Math.PI*2);
                this.ctx.fill();
            }
        });
        this.ctx.globalCompositeOperation = 'source-over';
        
        // 8. æ‘‡æ†ç»˜åˆ¶
        if(Joystick.active) {
            this.ctx.beginPath();
            this.ctx.fillStyle = 'rgba(255,255,255,0.1)';
            this.ctx.arc(Joystick.origin.x, Joystick.origin.y, 50, 0, Math.PI*2);
            this.ctx.fill();
            this.ctx.beginPath();
            this.ctx.fillStyle = 'rgba(255,255,255,0.5)';
            this.ctx.arc(Joystick.current.x, Joystick.current.y, 20, 0, Math.PI*2);
            this.ctx.fill();
        }
        
        // 9. æµ®åŠ¨æ–‡å­—
        this.ctx.font = "bold 16px Arial";
        this.texts.forEach(t => {
            this.ctx.fillStyle = t.color;
            this.ctx.fillText(t.str, t.x-cx, t.y-cy);
        });
    },
    
    drawPlayer: function(p) {
        const cx = this.camera.x;
        const cy = this.camera.y;
        const cfg = CONFIG[p.role];
        
        // æŠ¤ç›¾å…‰ç¯
        if(p.shield > 0) {
            this.ctx.beginPath();
            this.ctx.strokeStyle = '#00a8ff';
            this.ctx.lineWidth = 2;
            this.ctx.arc(p.x-cx, p.y-cy, 25, 0, Math.PI*2);
            this.ctx.stroke();
        }
        
        // æœ¬ä½“
        this.ctx.shadowBlur = 15;
        this.ctx.shadowColor = cfg.color;
        this.ctx.fillStyle = cfg.color;
        this.ctx.beginPath();
        this.ctx.arc(p.x-cx, p.y-cy, 20, 0, Math.PI*2);
        this.ctx.fill();
        this.ctx.shadowBlur = 0;
        
        // åå­—
        this.ctx.fillStyle = 'white';
        this.ctx.font = '12px Arial';
        this.ctx.textAlign = 'center';
        this.ctx.fillText(cfg.name, p.x-cx, p.y-cy-35);
        
        // è¡€æ¡
        this.ctx.fillStyle = 'black';
        this.ctx.fillRect(p.x-cx-20, p.y-cy-30, 40, 6);
        this.ctx.fillStyle = '#00ff88';
        this.ctx.fillRect(p.x-cx-20, p.y-cy-30, 40 * (p.hp/p.maxHp), 6);
    },
    
    drawEntity: function(x, y, r, c, emoji) {
        const cx = this.camera.x;
        const cy = this.camera.y;
        this.ctx.fillStyle = c;
        this.ctx.beginPath();
        this.ctx.arc(x-cx, y-cy, r, 0, Math.PI*2);
        this.ctx.fill();
        if(emoji) {
            this.ctx.font = (r*1.5) + "px Arial";
            this.ctx.textAlign = "center";
            this.ctx.textBaseline = "middle";
            this.ctx.fillText(emoji, x-cx, y-cy);
        }
    },
    
    addParticle: function(x, y, color, life, type='spark') {
        if(type === 'shockwave' || type === 'ring') {
            this.particles.push({x, y, color, life, type, vx:0, vy:0, size:0});
            return;
        }
        // çˆ†ç‚¸ç¢å±‘
        for(let i=0; i<5; i++) {
            const angle = Math.random() * Math.PI * 2;
            const speed = Math.random() * 5;
            this.particles.push({
                x, y, color, life: life + Math.random()*20,
                vx: Math.cos(angle)*speed, vy: Math.sin(angle)*speed,
                size: 2 + Math.random()*3, type
            });
        }
    },
    
    addFloatText: function(x, y, str, color) {
        this.texts.push({x, y, str, color, life: 60});
    },
    
    updateHUD: function() {
        document.getElementById('hud-hp-me').style.width = (this.me.hp / this.me.maxHp * 100) + "%";
        document.getElementById('hud-hp-base').style.width = (this.base.hp / this.base.maxHp * 100) + "%";
        if(this.mate.active) {
            document.getElementById('hud-hp-mate').style.width = (this.mate.hp / this.mate.maxHp * 100) + "%";
        }
    },
    
    showToast: function(msg) {
        const t = document.getElementById('msg-toast');
        t.innerText = msg;
        t.style.opacity = 1;
        setTimeout(() => t.style.opacity = 0, 2000);
    },
    
    shakeScreen: function(intensity) {
        // ç®€æ˜“éœ‡å±ï¼šç¨å¾®åç§» Camera å‡ æ¬¡
        const originalX = this.camera.x;
        const originalY = this.camera.y;
        let shake = intensity;
        const interval = setInterval(() => {
            this.camera.x = originalX + (Math.random()-0.5)*shake;
            this.camera.y = originalY + (Math.random()-0.5)*shake;
            shake *= 0.9;
            if(shake < 1) {
                clearInterval(interval);
            }
        }, 16);
    },

    loop: function() {
        this.update();
        this.draw();
        requestAnimationFrame(() => this.loop());
    }
};

// UI äº¤äº’
function selectRole(r) {
    myRole = r;
    document.querySelectorAll('.role-card').forEach(el => el.classList.remove('selected'));
    document.getElementById('role-' + r.toLowerCase()).classList.add('selected');
}

function tryConnect() {
    const room = document.getElementById('room-input').value;
    if(!room) return alert("è¯·è¾“å…¥æˆ¿é—´å·ï¼");
    
    document.getElementById('connect-btn').innerText = "è¿æ¥ä¸­...";
    document.getElementById('connect-btn').disabled = true;
    
    Net.init(room, () => {
        Game.init();
    });
}
</script>
</body>
</html>
